# Реализация Персептрона без использования сторонних библиотек (кроме рандомизации)
# Источник: https://habr.com/ru/sandbox/113114/

import random
import math

#--------------------------------------------------------------------------------------
# Обучение:
#   train(X, y, syn0, lens0, lens01, lr)
#       X: входные данные
#       y: выходные данные
#       syn: начальные веса синопсов
#       lens0:  количество выходных данных
#       lens01: количество данных в примере
#       lr: колличество итераций обучения

def train(X, y, syn0, lens0, lens01, lr):
    errorreturn = 0
    for i in range(0, lens0):
        a = 0
        for j in range(0, lens01):
            a = a + syn0[i][j] * X[j]
        b = 1 / (1 + math.e ** -a)
        error = y[i] - b
        errorreturn = errorreturn + abs(error)
        delta = (error) * 1 / (1 + math.e ** -b) * lr
        for z in range(0, lens01):
            syn0[i][z] = syn0[i][z] + X[z] * delta
    return syn0, errorreturn

#--------------------------------------------------------------------------------------
# Прогнозирование следующих lens0 значений
#   predict(syn0, X, lens0, lens01)
#       syn0: начальные веса синопсов
#       X: входные данные
#       lens0: кол-во входных данных
#       lens01: кол-во данных в примере

def predict(syn0, X, lens0, lens01):
    ret = []
    for i in range(0, lens0):
        a = 0
        for j in range(0, lens01):
            a = a + syn0[i][j] * X[j]
        b = 1 / (1 + math.e ** -a)
        ret.append(round (b, 2))
    return ret

#--------------------------------------------------------------------------------------
# Запуск обучения по всем входным данным
#   trainmass(X, y, syn, lens0, lens01, lr, iter)
#       iter: количество циклов обучения

def trainmass(X, y, syn, lens0, lens01, lr, iter):
    for i in range(iter):
        for j in range(lens01):
            syn, er = train(X[j], y[j], syn, lens0, lens01, lr)
    return syn, er

#--------------------------------------------------------------------------------------
# Создание массива весов для обучения
#   create(x, y)
#       x: размерноть по x
#       y: размерность по y

def create(x, y):
    syn0 = []
    for z in range(0, x):
        h = []
        for i in range(0, y):
            h.append(random.uniform(-0.1, 0.1))
        syn0.append(h)
    return syn0

#--------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------

syn = create(2, 8) # Создание массива начального случайного значения весов нейронов
print(syn)

# задание входного набора данных X
X = [
        [0.00, 0.01, 0.02, 0.03],[0.01, 0.02, 0.03, 0.04],
        [0.02, 0.03, 0.04, 0.05],[0.03, 0.04, 0.05, 0.06],
        [0.04, 0.05, 0.06, 0.07],[0.05, 0.06, 0.07, 0.08],
        [0.06, 0.07, 0.08, 0.09],[0.07, 0.08, 0.09, 0.10],
    
        [0.50, 0.51, 0.52, 0.53],[0.51, 0.52, 0.53, 0.54],
        [0.52, 0.53, 0.54, 0.55],[0.53, 0.54, 0.55, 0.56],
        [0.54, 0.55, 0.56, 0.57],[0.55, 0.56, 0.57, 0.58],
        [0.56, 0.57, 0.58, 0.59],[0.57, 0.58, 0.59, 0.60],
     ]
y = [
        [0.04, 0.05], [0.05, 0.06], 
        [0.06, 0.07], [0.07, 0.08],
        [0.08, 0.09], [0.09, 0.10], 
        [0.10, 0.11], [0.11, 0.12],
     
        [0.54, 0.55], [0.55, 0.56], 
        [0.56, 0.57], [0.57, 0.58],
        [0.58, 0.59], [0.59, 0.60], 
        [0.60, 0.61], [0.61, 0.62],
     ]

# обучение, вычисление весовых коэф-в
g, r = trainmass(X, y, syn, 2, 4, 100, 100000)

h = predict(syn, X[0], 2, 4)
h2 = predict(syn, X[10], 2, 4)
h3 = predict(syn, [0.30, 0.31, 0.32, 0.33], 2, 4)
print(h)
print(h2)
print(h3)

# Выводы:
